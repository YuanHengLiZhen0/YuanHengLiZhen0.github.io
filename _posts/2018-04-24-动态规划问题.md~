---
layout:     post
title:      动态规划问题
date:       2018-04-24
author:     zwht
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 算法
   
    
---

* TOC 
{:toc}

# 动态规划

### 定义
>     动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，**其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解**。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。通过保存子问题的状态,以空间换时间,可以极大的提高性能
- 初始条件
- 子问题划分
- 状态转移方程

### 基本概念和常见类型
**阶段**: (子问题)把所求解问题的过程分成若干个相互联系的阶段,描述阶段的变量称为阶段变量.
**状态**: (子问题的解)表示每个阶段开始面临的自然状况或客观条件
**无后效性**: 如果给定某一阶段的状态,则在这一阶段以后发展的不受这阶段以前各状态的影响.
- 矩阵型  序列型  划分型  区间型 背包型  状态压缩型 树型

### 常见问题
- 求最大值/最小值
- 求是否/可行不可行
- 求方案总数

### 例题
有1元、3元、5元面值的硬币若干，要凑到11元需要最少几个硬币？
类似的有爬楼梯(该类题目已经每一次能做的选择,求到达n需要的最少次数)
**解析:**到达n的方式:
-  是从n-1的位置加1元到n
-  是从n-3的位置加3元到n
-  是从n-5的位置加5元到n
故状态转移方程是f(n)=min{f(n-1),f(n-3),f(n-5)}+1;

```java
    public  int MinCount(int n){
        int dp[]=new int [n+6];
        for(int i=6;i<=n+5;i++){
              dp[i]=Math.min(Math.min(dp[i-1],dp[i-3]),dp[i-5])+1;
        }
        return dp[n+5];
    }
```





 
