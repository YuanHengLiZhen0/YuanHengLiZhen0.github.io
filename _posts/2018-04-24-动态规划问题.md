---
layout:     post
title:      动态规划问题
date:       2018-04-24
author:     zwht
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 算法
   
    
---

* TOC 
{:toc}

# 动态规划

### 定义
  动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，**其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解**。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。通过保存子问题的状态,以空间换时间,可以极大的提高性能

- 初始条件
- 子问题划分
- 状态转移方程

### 基本概念和常见类型

**阶段**: (子问题)把所求解问题的过程分成若干个相互联系的阶段,描述阶段的变量称为阶段变量.
**状态**: (子问题的解)表示每个阶段开始面临的自然状况或客观条件
**无后效性**: 如果给定某一阶段的状态,则在这一阶段以后发展的不受这阶段以前各状态的影响.
- 矩阵型  序列型  划分型  区间型 背包型  状态压缩型 树型

### 常见问题

- 求最大值/最小值
- 求是否/可行不可行
- 求方案总数

### 动规,递推,递归,迭代
**迭代:**计算机重复执行某组指令, 就是循环(for ,while)
**递归:**方法自己调用自己,将复杂问题一步步变为简单问题
**递推:**从简单问题出发,一步步变为复杂问题


###动态规划和贪心算法的区别
`相同点:`

动态规划和贪心算法都是一种递推算法 。
均有局部最优解来推导全局最优解 。

`不同点:`

**贪心算法：**

贪心算法中，作出的每步贪心决策都无法改变，因为`贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。`
由（1）中的介绍，可以知道贪心法正确的条件是：每一步的最优解一定包含上一步的最优解。

**动态规划算法：**

全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解
动态规划的关键是状态转移方程，即如何由以求出的局部最优解来推导全局最优解
边界条件：即最简单的，可以直接得出的局部最优解 
  

### 例题

一,有1元、3元、4元面值的硬币若干，要凑到11元需要最少几个硬币？
类似的有爬楼梯(该类题目已经每一次能做的选择,求到达n需要的最少次数)

**动规解析:**到达n的方式:
-  是从n-1的位置加1元到n
-  是从n-3的位置加3元到n
-  是从n-4的位置加5元到n
故状态转移方程是f(n)=min{f(n-1),f(n-3),f(n-4)}+1;

```java
    public  int MinCount(int n){
        int dp[]=new int [n+6];
        for(int i=6;i<=n+5;i++){
              dp[i]=Math.min(Math.min(dp[i-1],dp[i-3]),dp[i-5])+1;
        }
        return dp[n+5];
    }
```
**贪心解析:**到达n的方式:
- 到达11最大的面值是4,所以变成凑到(11-4)需要的最少硬币
- 7-4
- 3-3
所以是3个

但是,`贪心算法得到并不一定是最优解,它只是较优解`如6个硬币的贪心算法是1,1,4(3个硬币)而实际只用3,3(2个)

二,LCS最长公共子序列问题

字符串的动规问题,一般是O(n方)

```java
     public static void LCS(String x, String y){
        char[] s1 = x.toCharArray();  
        char[] s2 = y.toCharArray();  
        int[][] dp = new int[x.length()+1][y.length()+1];
                  
        for(int j = 0; j < dp[0].length; j++){ 
            dp[0][j] = 0;  
        }  
        for(int i = 0; i < dp.length; i++){
            dp[i][0] = 0;  
        }  
          
        for(int i = 1; i < dp.length; i++){
            for(int j = 1; j < dp[0].length; j++){  
                if(s1[i - 1] == s2[j - 1]){  
                    array[i][j] = dp[i-1][j-1] + 1;
                }else{  
                    array[i][j] = max(dp[i -1][j], dp[i][j -1]);
                }  
            }  
        } 
```






